# Дискретна Математика II - Лабораторна робота з теми "Криптографія"
## Розподіл на завдання:
> - Тарас Левицький - Message integrity, взаємодія клієнту й серверу
> - Максим Мацелюх - RSA (генерація ключів, encrypting, decrypting)

## 1. Генерація RSA-ключів

У першому пункті лабораторної було реалізовано генерацію ключів для шифрування повідомлень за допомогою алгоритму RSA.

Алгоритм дозволяє двом сторонам безпечно обмінятися зашифрованими повідомленнями, навіть якщо зловмисник бачить трафік. Основна ідея полягає у використанні **пари ключів**: публічного і приватного.

### Як працює генерація ключів

1. **Генерація простих чисел `p` і `q`:**
   - Випадковим чином обираються два великі прості числа. У нашій реалізації використовується перевірка на простоту методом Міллера–Рабіна.
2. **Обчислюється `n = p * q`:**
   - Це модуль, який буде використовуватись і в публічному, і в приватному ключі.
3. **Обчислюється функція Ейлера `phi(n) = (p - 1)(q - 1)`:**
   - Вона потрібна для подальших обчислень.
4. **Обирається число `e`:**
   - Воно повинно бути взаємно простим з `phi(n)`. У нашій реалізації ми вибрали 65537
5. **Обчислюється `d` — мультиплікативно обернене до `e` за модулем `phi(n)`:**
   - Тобто таке число, щоб `(d * e) % phi(n) == 1`. Для цього використовується розширений алгоритм Евкліда.

### Реалізовані функції

- `is_prime(n: int, k: int = 5) -> bool` — перевіряє, чи є число простим за допомогою тесту Міллера–Рабіна.
- `generate_prime(bits: int) -> int` — генерує дійсне просте число.
- `egcd(a: int, b: int) -> tuple[int,int,int]` — знаходить найбільший спільний дільник.
- `modinv(a: int, m: int) -> int` — обчислює обернений елемент до `e` за модулем `phi`.
- `generate_keys(bits: int = 16) -> tuple[tuple[int,int], tuple[int,int]]` — основна функція генерації ключів. Повертає пару: приватний і публічний ключі.

Також у модулі `encoding_util.py` були реалізовані функції кодування і розкодування:

### Функція `encrypt`

```python
def encrypt(pubkey: tuple[int, int], plaintext: bytes) -> bytes:
    e, n = pubkey
    block_size = (n.bit_length() + 7) // 8
    max_plain_size = block_size - 1
    cipher_blocks = []

    for i in range(0, len(plaintext), max_plain_size):
        block = plaintext[i:i + max_plain_size]
        if len(block) < max_plain_size:
            block = b'\x00' + block
        num = int.from_bytes(block, byteorder='big')
        encrypted_num = pow(num, e, n)
        cipher_blocks.append(encrypted_num.to_bytes(block_size, byteorder='big'))

    return b''.join(cipher_blocks)
```

#### Призначення:
Функція шифрує вхідні байти (`plaintext`) за допомогою відкритого ключа RSA.

#### Як працює:
1. Витягуються значення `e` і `n` з пари `pubkey`.
2. Обчислюється розмір блоку `block_size` на основі розміру модуля `n`.
3. Встановлюється максимальний розмір відкритого блоку `max_plain_size` як `block_size - 1`.
4. Повідомлення розбивається на блоки, кожен з яких шифрується окремо:
   - Якщо блок коротший за `max_plain_size`, до нього додається нульовий байт зліва.
   - Блок перетворюється у число `num`.
   - Застосовується шифрування RSA: `encrypted_num = pow(num, e, n)`.
   - Отримане число перетворюється назад у байти відповідного розміру.
5. Усі зашифровані блоки об'єднуються у фінальний зашифрований результат.

---

### Функція `decrypt`

```python
def decrypt(privkey: tuple[int, int], ciphertext: bytes) -> bytes:
    d, n = privkey
    block_size = (n.bit_length() + 7) // 8
    plain_blocks = []

    for i in range(0, len(ciphertext), block_size):
        block = ciphertext[i:i + block_size]
        num = int.from_bytes(block, byteorder='big')
        decrypted_num = pow(num, d, n)
        decrypted_bytes = decrypted_num.to_bytes(block_size, byteorder='big').lstrip(b'\x00')
        plain_blocks.append(decrypted_bytes)

    return b''.join(plain_blocks)
```

#### Призначення:
Функція розшифровує зашифроване повідомлення (`ciphertext`) за допомогою приватного ключа RSA.

#### Як працює:
1. Витягуються значення `d` і `n` з пари `privkey`.
2. Обчислюється розмір блоку `block_size`, який відповідає розміру модуля `n`.
3. Цифротекст розбивається на блоки, кожен з яких розшифровується:
   - Кожен блок перетворюється у ціле число.
   - Застосовується розшифрування RSA: `decrypted_num = pow(num, d, n)`.
   - Результат перетворюється назад у байти та обрізається нульовий байт на початку, якщо такий є.
4. Усі розшифровані блоки об'єднуються у фінальне повідомлення у вигляді байтів.

---

> Ці дві функції реалізують базову схему блочного RSA-шифрування для довільного повідомлення у вигляді байтів.


На цьому етапі ми реалізували механізм створення ключової пари, що дозволяє переходити до наступних етапів — обміну публічними ключами між клієнтом і сервером, шифрування повідомлень та перевірки їхньої цілісності.

## Імплементація обміну публічними ключами між клієнтом і сервером, шифрування повідомлень та перевірки їхньої цілісності.

При ініціалізації сервер генерує публічний та приватний ключі (e, d, n - про це детальніше в розділі RSA). 
```
def start(self):
        self.s.bind((self.host, self.port))
        self.s.listen(100)

        self.public_key, self.private_key, self.n = enc_util.generate_keys()
```
Клієнт при приєднанні до серверу також генерує свої ключі, а також обмінюється з сервером публічними ключами.
>client.py (Client.init_connection())
```
self.public_key,self.private_key,self.n = enc_util.generate_keys()

        # exchange public keys
        self.server_public_key = int(self.s.recv(1024))
        self.server_n = int(self.s.recv(1024))
        msg = f"{self.public_key}"
        self.s.send(msg.encode())
        msg = f"{self.n}"
        self.s.send(msg.encode())
```
>server.py (Server.start())
```
msg = f"{self.public_key}"
            c.send(msg.encode())
            msg = f"{self.n}"
            c.send(msg.encode())
            c_pub_key = c.recv(1024).decode()
            n = c.recv(1024).decode()
            self.c_pub_keys.append( (int(c_pub_key),int(n)) )
```
При надсиланні повідомлення з клієнту відбувається такий алгоритм дій:
- Клієнт кодує повідомлення публічним серверним ключем й надсилає на сервер повідомлення разом з хешем (для перевірки цілісності повідомлення)
- Сервер отримує й розкодовує повідомлення своїм приватним ключем, й надсилає всім іншим клієнтам використовуючи їхні публічні ключі
- Клієнти отримують повідомлення й розкодовують своїми приватними ключами, та перевіряють хеш, якщо він не співпадає - повідомлення було зміненим під час передачі, отже вже не дійсне
> При передачі байтів складно зрозуміти, де закінчується повідомлення, а де починається хеш. Для цього використовуються json та base64.
